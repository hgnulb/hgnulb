---
layout: post
title: "设计模式-单例模式"
permalink: /blog/50659901
categories: [设计模式]
tags: [设计模式]
date: 2020-10-05 15:22:21
---

* Kramdown table of contents
{:toc .toc}
## 单例模式（Singleton）

定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

特点：

> 1、单例模式只能有一个实例。
>
> 2、单例类必须创建自己的唯一实例。
>
> 3、单例类必须向其他对象提供这一实例。

![image-20201005121215846](../assets/post-list/img/image-20201005121215846.png)

## 双重校验单例模式

```java
import java.io.Serializable;

/**
 * Created by hgnulb on 2020/8/22 11:20
 */
public class Singleton implements Serializable, Cloneable {
    private volatile static Singleton instance = null;

    private Singleton() { // 私有化构造方法
        // 防止反射
        if (instance != null) {
            throw new RuntimeException("单例模式不允许重复创建对象。");
        }
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return instance; // 防止clone
    }

    private Object readResolve() {
        return instance; // 防止序列化
    }
}
```

## 枚举式单例模式

```java
/**
 * Created by hgnulb on 2020/8/22 12:24
 */
public enum Singleton {
    INSTANCE;
}

class Test {
    public static void main(String[] args) {
        Singleton instance1 = Singleton.INSTANCE;
        Singleton instance2 = Singleton.INSTANCE;
        System.out.println(instance1 == instance2);
    }
}
```

## 静态内部类单例模式

```java
/**
 * Created by hgnulb on 2020/8/22 12:22
 */

/**
 * 懒汉式（静态内部类）线程安全
 */
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

## 静态代码块单例模式

```java
/**
 * Created by hgnulb on 2020/8/22 12:23
 */
public class Singleton {
    private static Singleton instance = null;

    static {
        instance = new Singleton();
    }

    private Singleton() {
    }

    public static Singleton getInstance() {
        return instance;
    }
}
```

## 静态常量单例模式

```java
/**
 * Created by hgnulb on 2020/8/22 12:23
 */

/**
 * 饿汉式，线程安全
 */
public class Singleton {
    private static final Singleton singleton = new Singleton();

    //限制产生多个对象
    private Singleton() {
    }

    //通过该方法获得实例对象
    public static Singleton getSingleton() {
        return singleton;
    }
}
```

## 同步代码块单例模式

```java
/**
 * Created by hgnulb on 2020/8/22 12:12
 */
public class Singleton {
    private static Singleton instance = null;

    private Singleton() {
    }

    public static Singleton getInstance() {
        synchronized (Singleton.class) {
            if (instance == null) {
                instance = new Singleton();
            }
            return instance;
        }
    }
}
```

## 同步方法单例模式

```java
/**
 * Created by hgnulb on 2020/8/22 12:18
 */
public class Singleton {
    private static Singleton instance = null;

    private Singleton() {
    }

    public synchronized static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

## 单例模式在 JDK 中的应用

```java
java.lang.Runtime#getRuntime()
java.awt.Desktop#getDesktop()
java.lang.System#getSecurityManager()
```

![image-20201018214347359](../assets/post-list/img/image-20201018214347359.png)

![image-20201027221639590](../assets/post-list/img/image-20201027221639590.png)

## 单例模式常见面试题

- 写出一个单例模式，为什么要用 voliate 修饰? 出现 synchronized 为啥还需要 voliate，以及 synchronized 能保证啥？
- 懒汉式单例实现时需要加几层检查，为什么？需不需要使用 volatile。为什么不使用 volatile 会导致线程不安全。
- 说一说常用的设计模式，单例模式如何保证线程安全。
- 单例模式的几种实现方式？
- 单例模式用 Java 有哪几种实现方式?
- 编写单例模式饿汉式和懒汉式代码和区别？
- 单例模式的实际应用场景？
- 单例和多例什么区别？
- 如何防止反射破坏单例？
- 线程安全的单例模式？
- 手写一个单例。(防止序列化、防止反射、防止 clone)

## 推荐阅读

- [如何正确地写出单例模式](http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/)