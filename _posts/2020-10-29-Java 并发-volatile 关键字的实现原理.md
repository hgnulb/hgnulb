---
layout: post
title: "Java 并发-volatile 关键字的实现原理"
permalink: /blog/84545899
categories: [Java 并发]
tags: [Java 并发]
date: 2020-10-29 21:38:40
---

* Kramdown table of contents
{:toc .toc}
## volatile 关键字概述

当一个变量被定义成 volatile 之后，它将具备两项特性：

> 第一项是保证此变量对所有线程的可见性，这里的"可见性"是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再对主内存进行读取操作，新变量值才会对线程 B 可见。
>
> 使用 volatile 变量的第二个语义是禁止指令重排序优化，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。
>

valotile 的内存语义：

> 可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。
>
> 原子性。对任意单个 volatile 变量的读、写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。
>
> 从内存语义的角度来说，volatile 的写-读与锁的释放-获取有相同的内存效果。volatile 写和锁的释放有相同的内存语义；volatile 读与锁的获取有相同的内存语义。
>

volatile 写-读的内存语义：

> volatile 写的内存语义如下。当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。
>
> volatile 读的内存语义如下。当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。
>
> 如果我们把 volatile 写和 volatile 读两个步骤综合起来看的话，在读线程 B 读一个 volatile 变量后，写线程 A 在写这个 volatile 变量之前所有可见的共享变量的值都将立即变得对读线程 B 可见。
>

下面对 volatile 写和 volatile 读的内存语义做个总结：

> 线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了（其对共享变量所做修改的）消息。
>
> 线程 B 读一个 volatile 变量，实质上是线程 B 接收了之前某个线程发出的（在写这个 volatile 变量之前对共享变量所做修改的）消息。
>
> 线程 A 写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。

锁的内存语义：

> 锁是 Java 并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。
>

锁的释放和获取的内存语义：

> 当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。
>
> 当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。
>
> 对比锁释放-获取的内存语义与 volatile 写-读的内存语义可以看出：锁释放与 volatile 写有相同的内存语义；锁获取与 volatile 读有相同的内存语义。
>

下面对锁释放和锁获取的内存语义做个总结：

> 线程 A 释放一个锁，实质上是线程 A 向接下来将要获取这个锁的某个线程发出了（线程 A 对共享变量所做修改的）消息。
>
> 线程 B 获取一个锁，实质上是线程 B 接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。
>
> 线程 A 释放锁，随后线程 B 获取这个锁，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。

由于 Java 的 CAS 同时具有 volatile 读和 volatile 写的内存语义，因此 Java 线程之间的通信现在有了下面 4 种方式。

> 1）A 线程写 volatile 变量，随后 B 线程读这个 volatile 变量。
>
> 2）A 线程写 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。
>
> 3）A 线程用 CAS 更新一个 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。
>
> 4）A 线程用 CAS 更新一个 volatile 变量，随后 B 线程读这个 volatile 变量。

## volatile 关键字常见面试题

- [ ] 说一说 volatile 关键字的作用以及底层原理？volatile 是如何保证可见性的以及实现可见性的机制？它能保证原子性吗？
- [ ] 如何保障一个线程修改一个变量对其他线程是可见的？缓存一致性协议如何保障可见性？
- [ ] 如果大量的使用 volatile 存在什么问题？volatile 是线程安全的吗？指令重排序是怎么回事。a++ 能用 volatile 禁止指令重排序吗？
- [ ] volatile 的语义，虚拟机如何实现 volatile，volatile 的使用场景。
- [ ] 你说的主存指的是什么？和主存对应的是什么？主存和堆是什么关系？
- [ ] 内存屏障分几种？除了在 volatile 中使用了内存屏障，Java 还有哪里使用了内存屏障。
- [ ] 单例的几种写法。volatile 关键字有什么作用。

## 推荐阅读

- [全面理解Java内存模型(JMM)及volatile关键字](https://blog.csdn.net/javazejian/article/details/72772461)